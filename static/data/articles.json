{"articles":[{"_id":"5d763b96c06bbc1bb4d7f021","title":"Bootstrap3 常用的类","introduce":"Bootstrap3 常用的类 布局容器 container 响应式容器  container-fluid 流式容器","type":"Css","content_html":"<h1><a id=\"centerBootstrap3_center_0\"></a><center>Bootstrap3 常用的类</center></h1>\n<h4><a id=\"_2\"></a>布局容器</h4>\n<blockquote>\n<p>container 响应式容器</p>\n</blockquote>\n<blockquote>\n<p>container-fluid 流式容器</p>\n</blockquote>\n<h4><a id=\"_8\"></a>栅格系统</h4>\n<!-- more -->\n<blockquote>\n<p>row 行</p>\n</blockquote>\n<blockquote>\n<p>col-*-* 列</p>\n</blockquote>\n<pre><code class=\"lang-\">实例 col-md-3\n第一个参数:\n  lg 大屏：大屏及以上生效\n  md 中屏：中屏及以上生效\n  sm 小屏：小屏及以上生效\n  xs 超小屏：超小屏及以上生效\n第二个参数:Row 默认会把一行分成 12 等份列，这里第二个参数表示的是当前元素占 12 等份当中的几份\n</code></pre>\n<blockquote>\n<p>col-xs-offset-4 偏移，往右偏移四等份</p>\n</blockquote>\n<blockquote>\n<p>col-xs-push-* 排序 往后推几份<br />\ncol-xs-pull-* 排序 往前拉几份</p>\n</blockquote>\n<blockquote>\n<p>hidden-* 控制在某种屏幕下隐藏，其他屏幕可见，可选参数 lg、md、sm、xs</p>\n</blockquote>\n<blockquote>\n<p>pull-left 左浮动<br />\npull-right 右浮动</p>\n</blockquote>\n<blockquote>\n<p>text-right 文字右对齐<br />\ntext-left 文字左对齐<br />\ntext-center 居中</p>\n</blockquote>\n","content_md":"# <center>Bootstrap3 常用的类</center>\n\n#### 布局容器\n\n> container 响应式容器\n\n> container-fluid 流式容器\n\n#### 栅格系统\n\n<!-- more -->\n\n> row 行\n\n> col-\\*-\\* 列\n\n```\n实例 col-md-3\n第一个参数:\n  lg 大屏：大屏及以上生效\n  md 中屏：中屏及以上生效\n  sm 小屏：小屏及以上生效\n  xs 超小屏：超小屏及以上生效\n第二个参数:Row 默认会把一行分成 12 等份列，这里第二个参数表示的是当前元素占 12 等份当中的几份\n```\n\n> col-xs-offset-4 偏移，往右偏移四等份\n\n> col-xs-push-\\* 排序 往后推几份\n> col-xs-pull-\\* 排序 往前拉几份\n\n> hidden-\\* 控制在某种屏幕下隐藏，其他屏幕可见，可选参数 lg、md、sm、xs\n\n> pull-left 左浮动\n> pull-right 右浮动\n\n> text-right 文字右对齐\n> text-left 文字左对齐\n> text-center 居中","clickCount":99,"date":"2019-09-17T14:19:21.931Z"},{"_id":"5d765fe8858cff1d946a07fb","title":"CSS3 background属性","introduce":"CSS3 background属性","type":"Css","content_html":"<h1><a id=\"centerCSS3_backgroundcenter_0\"></a><center>CSS3 background属性</center></h1>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>示例</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>背景颜色</td>\n<td>background-color: red;</td>\n<td></td>\n</tr>\n<tr>\n<td>背景图片</td>\n<td>background-image: url(iamges/***.jpg);</td>\n<td></td>\n</tr>\n<tr>\n<td>背景平铺</td>\n<td>background-repeat: repeat-x;background-repeat: repeat-x;</td>\n<td>-x:横向平铺；-y:纵向平铺；no-repeat为取消平铺</td>\n</tr>\n<tr>\n<td>背景图片位置(一)</td>\n<td>background-position: left top;<br/>background-position: right bottom;<br/>background-position: center;</td>\n<td>分别为左上、右下、居中，若只写一个属性则另一个默认为center</td>\n</tr>\n<tr>\n<td>背景图片位置(二)</td>\n<td>background-position: 10px 30px;</td>\n<td>第一个值为水平坐标，第二个值为纵向坐标</td>\n</tr>\n<tr>\n<td>背景图片位置(三)：混搭</td>\n<td>background-position: 10px center;</td>\n<td>横向10px，纵向居中</td>\n</tr>\n<tr>\n<td>背景附着</td>\n<td>background-attachment: scroll / fixed;</td>\n<td>默认是scroll</td>\n</tr>\n<tr>\n<td>背景缩放（一）</td>\n<td>background-size: 50%;<br/>background-size: 100px 200px;</td>\n<td>缩放为原来一半大小；宽100px，高200px，尽量只改一个值，防止图片失真</td>\n</tr>\n<tr>\n<td>背景缩放（二）</td>\n<td>background-size: cover / contain;</td>\n<td>cover：会自动调整缩放比列，保证图片始终填充满背景区域，移出部分会被隐藏;contain:自动调整缩放比例，保证图片完整显示，但背景可能会有部分裸露</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>简写方式:background: 颜色 图片 平铺 附着 位置</p>\n</blockquote>\n<pre><code class=\"lang-style\">&lt;style&gt;\n\tbody{\n\t\tbackground: #000 url(img/xxx.jpg) no-repeat fixed center -25px;\n\t}\n&lt;/style&gt;\n</code></pre>\n<p>凹凸文字效果</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我是凸起的文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>我是凹下的文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n   <span class=\"hljs-selector-tag\">body</span> {\n       <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#ccc</span>;\n   }\n   <span class=\"hljs-selector-tag\">div</span> {\n       <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#ccc</span>;\n       <span class=\"hljs-attribute\">font</span>: <span class=\"hljs-number\">700</span> <span class=\"hljs-number\">80px</span> <span class=\"hljs-string\">\"微软雅黑\"</span>;\n   }\n   <span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-pseudo\">:first-child</span> {\n       <span class=\"hljs-attribute\">text-shadow</span>: <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#000</span>,-<span class=\"hljs-number\">1px</span> -<span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#fff</span>;\n   }\n   <span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-pseudo\">:last-child</span> {\n       <span class=\"hljs-attribute\">text-shadow</span>: -<span class=\"hljs-number\">1px</span> -<span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#000</span>,<span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">#fff</span>;\n   }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n</code></div></pre>\n","content_md":"# <center>CSS3 background属性</center>\n\n属性|示例|备注\n--|--|--\n背景颜色|background-color: red;|\n背景图片|background-image: url(iamges/\\***.jpg);|\n背景平铺|background-repeat: repeat-x;background-repeat: repeat-x;|-x:横向平铺；-y:纵向平铺；no-repeat为取消平铺\n背景图片位置(一)|background-position: left top;<br/>background-position: right bottom;<br/>background-position: center;|分别为左上、右下、居中，若只写一个属性则另一个默认为center\n背景图片位置(二)|background-position: 10px 30px;|第一个值为水平坐标，第二个值为纵向坐标\n背景图片位置(三)：混搭|background-position: 10px center;|横向10px，纵向居中\n背景附着|background-attachment: scroll / fixed;|默认是scroll\n背景缩放（一）|background-size: 50%;<br/>background-size: 100px 200px;|缩放为原来一半大小；宽100px，高200px，尽量只改一个值，防止图片失真\n背景缩放（二）|background-size: cover / contain;|cover：会自动调整缩放比列，保证图片始终填充满背景区域，移出部分会被隐藏;contain:自动调整缩放比例，保证图片完整显示，但背景可能会有部分裸露\n> 简写方式:background: 颜色 图片 平铺 附着 位置\n``` style\n<style>\n\tbody{\n\t\tbackground: #000 url(img/xxx.jpg) no-repeat fixed center -25px;\n\t}\n</style>\n```\n\n凹凸文字效果\n``` html\n<body>\n   <div>我是凸起的文字</div>\n   <div>我是凹下的文字</div>\n</body>\n<style>\n   body {\n       background-color: #ccc;\n   }\n   div {\n       color: #ccc;\n       font: 700 80px \"微软雅黑\";\n   }\n   div:first-child {\n       text-shadow: 1px 1px 1px #000,-1px -1px 1px #fff;\n   }\n   div:last-child {\n       text-shadow: -1px -1px 1px #000,1px 1px 1px #fff;\n   }\n</style>\n```","clickCount":99,"date":"2019-09-10T11:46:31.926Z"},{"_id":"5d79012e7a3a8c1ea4648cd8","title":"CSS3-Flex 布局","introduce":"决定主轴的方向,即元素排列的方向，有四种方式...","type":"Css","content_html":"<div class=\"hljs-center\">\n<h1><a id=\"CSS3Flex__2\"></a>CSS3-Flex 布局</h1>\n</div>\n<hr />\n<h4><a id=\"Flex__11\"></a>Flex 属性详述</h4>\n<h5><a id=\"1_flexdirection_13\"></a>1. flex-direction</h5>\n<blockquote>\n<p>决定主轴的方向,即元素排列的方向，有四种方式:</p>\n</blockquote>\n<!-- more -->\n<ul>\n<li>\n<p>row: 主轴为水平方向，元素沿主轴从左至右排列</p>\n</li>\n<li>\n<p>column: 主轴为竖直方向，元素沿主轴从上至下排列</p>\n</li>\n<li>\n<p>row-reverse: 主轴水平，元素从右至左排列，与 row 反向</p>\n</li>\n<li>\n<p>column-reverse: 主轴竖直，元素从下至上排列，与 column 反向</p>\n</li>\n</ul>\n<h5><a id=\"2_flexwrap_27\"></a>2. flex-wrap</h5>\n<blockquote>\n<p>默认情况下，item 排列在一条线上，即主轴上，flex-wrap 决定当排列不下时是否换行以及换行的方式，有三种方式|wrap|wrap-reverse</p>\n</blockquote>\n<ul>\n<li>\n<p>nowrap: 自动缩小项目，不换行</p>\n</li>\n<li>\n<p>wrap: 换行,第一行在上方</p>\n</li>\n<li>\n<p>wrap-reverse: 换行，第一行在下方</p>\n</li>\n</ul>\n<h5><a id=\"3_flexflow_37\"></a>3. flex-flow</h5>\n<blockquote>\n<p>flex-direction 和 flex-wrap 的简写形式</p>\n</blockquote>\n<blockquote>\n<p>如：row wrap 、 column wrap-reverse 等。默认值为 row nowrap，即横向排列 不换行。</p>\n</blockquote>\n<h5><a id=\"4_justifycontent_43\"></a>4. justify-content</h5>\n<blockquote>\n<p>决定元素在主轴上的对齐方式，当主轴沿水平方向时,有五种方式：</p>\n</blockquote>\n<ul>\n<li>\n<p>flex-start(默认): 左对齐</p>\n</li>\n<li>\n<p>flex-end: 右对齐</p>\n</li>\n<li>\n<p>center: 居中对齐</p>\n</li>\n<li>\n<p>space-between: 两端对齐</p>\n</li>\n<li>\n<p>space-around: 沿轴线均匀分布</p>\n</li>\n</ul>\n<h5><a id=\"5_alignitems_57\"></a>5. align-items</h5>\n<blockquote>\n<p>决定元素在交叉轴上的对齐方式，当主轴沿水平方向时，有五种方式：</p>\n</blockquote>\n<ul>\n<li>\n<p>flex-start: 顶端对齐</p>\n</li>\n<li>\n<p>flex-end: 底部对齐</p>\n</li>\n<li>\n<p>center: 竖直方向上居中对齐</p>\n</li>\n<li>\n<p>baseline: 元素第一行文字的底部对齐</p>\n</li>\n<li>\n<p>stretch: 当元素未设置高度时，元素将和容器等高对齐</p>\n</li>\n</ul>\n<h5><a id=\"5_aligncontent_71\"></a>5. align-content</h5>\n<blockquote>\n<p>该属性定义了当有多根主轴时，即 item 不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，定义了 align-content 后，align-items 属性将失效。align-content 可能值含义如下（假设主轴为水平方向）：</p>\n</blockquote>\n<ul>\n<li>\n<p>flex-start：左对齐</p>\n</li>\n<li>\n<p>flex-end：右对齐</p>\n</li>\n<li>\n<p>center：居中对齐</p>\n</li>\n<li>\n<p>space- between：两端对齐</p>\n</li>\n<li>\n<p>space-around：沿轴线均匀分布</p>\n</li>\n<li>\n<p>stretch：各行将根据其 flex-grow 值伸展以充分占据剩余空间</p>\n</li>\n</ul>\n<h4><a id=\"flex_item__87\"></a>flex item 属性详述</h4>\n<h5><a id=\"1_order_89\"></a>1. order</h5>\n<blockquote>\n<p>der 的值是整数，默认为 0，整数越小，item 排列越靠前</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"wrap\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"order:4\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"order:2\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"order:3\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"order:1\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<h5><a id=\"2_flexgrow_105\"></a>2. flex-grow</h5>\n<blockquote>\n<p>定义了当 flex 容器有多余空间时，item 是否放大。默认值为 0，即当有多余空间时也不放大；可能的值为整数，表示不同 item 的放大比例，如</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"wrap\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"flex-grow:1\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"flex-grow:2\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"flex-grow:3\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<p><code>即当有多余空间时item1、item2、和item3以1：2:3的比例放大。</code></p>\n<h5><a id=\"3_flexshrink_121\"></a>3. flex-shrink</h5>\n<blockquote>\n<p>定义了当容器空间不足时，item 是否缩小。默认值为 1，表示当空间不足时，item 自动缩小，其可能的值为整数，表示不同 item 的缩小比例。</p>\n</blockquote>\n<h5><a id=\"4_flexbasis_125\"></a>4. flex-basis</h5>\n<blockquote>\n<p>项目在主轴上占据的空间，默认值为 auto。如下代码</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"wrap\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"flex-basis:80px\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"flex-basis:160px\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"div\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"flex-basis:240px\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>item 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></div></pre>\n<h5><a id=\"5_flex_139\"></a>5. flex</h5>\n<blockquote>\n<p>flex 属性是 flex-grow、flex-shrink 和 flex-basis 三属性的简写总和.</p>\n</blockquote>\n<h5><a id=\"6_alignself_143\"></a>6. align-self</h5>\n<blockquote>\n<p>align-self 属性允许 item 有自己独特的在交叉轴上的对齐方式，它有六个可能的值。默认值为 auto</p>\n</blockquote>\n<ul>\n<li>\n<p>auto：和父元素 align-self 的值一致</p>\n</li>\n<li>\n<p>flex-start：顶端对齐</p>\n</li>\n<li>\n<p>flex-end：底部对齐</p>\n</li>\n<li>\n<p>center：竖直方向上居中对齐</p>\n</li>\n<li>\n<p>baseline：item 第一行文字的底部对齐</p>\n</li>\n<li>\n<p>stretch：当 item 未设置高度时，item 将和容器等高对齐</p>\n</li>\n</ul>\n","content_md":"::: hljs-center\n\n# CSS3-Flex 布局\n\n:::\n\n\n\n\n---\n\n#### Flex 属性详述\n\n##### 1. flex-direction\n\n> 决定主轴的方向,即元素排列的方向，有四种方式:\n\n<!-- more -->\n\n- row: 主轴为水平方向，元素沿主轴从左至右排列\n\n- column: 主轴为竖直方向，元素沿主轴从上至下排列\n\n- row-reverse: 主轴水平，元素从右至左排列，与 row 反向\n\n- column-reverse: 主轴竖直，元素从下至上排列，与 column 反向\n\n##### 2. flex-wrap\n\n> 默认情况下，item 排列在一条线上，即主轴上，flex-wrap 决定当排列不下时是否换行以及换行的方式，有三种方式|wrap|wrap-reverse\n\n- nowrap: 自动缩小项目，不换行\n\n- wrap: 换行,第一行在上方\n\n- wrap-reverse: 换行，第一行在下方\n\n##### 3. flex-flow\n\n> flex-direction 和 flex-wrap 的简写形式\n\n> 如：row wrap 、 column wrap-reverse 等。默认值为 row nowrap，即横向排列 不换行。\n\n##### 4. justify-content\n\n> 决定元素在主轴上的对齐方式，当主轴沿水平方向时,有五种方式：\n\n- flex-start(默认): 左对齐\n\n- flex-end: 右对齐\n\n- center: 居中对齐\n\n- space-between: 两端对齐\n\n- space-around: 沿轴线均匀分布\n\n##### 5. align-items\n\n> 决定元素在交叉轴上的对齐方式，当主轴沿水平方向时，有五种方式：\n\n- flex-start: 顶端对齐\n\n- flex-end: 底部对齐\n\n- center: 竖直方向上居中对齐\n\n- baseline: 元素第一行文字的底部对齐\n\n- stretch: 当元素未设置高度时，元素将和容器等高对齐\n\n##### 5. align-content\n\n> 该属性定义了当有多根主轴时，即 item 不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，定义了 align-content 后，align-items 属性将失效。align-content 可能值含义如下（假设主轴为水平方向）：\n\n- flex-start：左对齐\n\n- flex-end：右对齐\n\n- center：居中对齐\n\n- space- between：两端对齐\n\n- space-around：沿轴线均匀分布\n\n- stretch：各行将根据其 flex-grow 值伸展以充分占据剩余空间\n\n#### flex item 属性详述\n\n##### 1. order\n\n> der 的值是整数，默认为 0，整数越小，item 排列越靠前\n\n```html\n<div class=\"wrap\">\n  <div class=\"div\" style=\"order:4\"><h2>item 1</h2></div>\n\n  <div class=\"div\" style=\"order:2\"><h2>item 2</h2></div>\n\n  <div class=\"div\" style=\"order:3\"><h2>item 3</h2></div>\n\n  <div class=\"div\" style=\"order:1\"><h2>item 4</h2></div>\n</div>\n```\n\n##### 2. flex-grow\n\n> 定义了当 flex 容器有多余空间时，item 是否放大。默认值为 0，即当有多余空间时也不放大；可能的值为整数，表示不同 item 的放大比例，如\n\n```html\n<div class=\"wrap\">\n  <div class=\"div\" style=\"flex-grow:1\"><h2>item 1</h2></div>\n\n  <div class=\"div\" style=\"flex-grow:2\"><h2>item 2</h2></div>\n\n  <div class=\"div\" style=\"flex-grow:3\"><h2>item 3</h2></div>\n</div>\n```\n\n`即当有多余空间时item1、item2、和item3以1：2:3的比例放大。`\n\n##### 3. flex-shrink\n\n> 定义了当容器空间不足时，item 是否缩小。默认值为 1，表示当空间不足时，item 自动缩小，其可能的值为整数，表示不同 item 的缩小比例。\n\n##### 4. flex-basis\n\n> 项目在主轴上占据的空间，默认值为 auto。如下代码\n\n```html\n<div class=\"wrap\">\n  <div class=\"div\" style=\"flex-basis:80px\"><h2>item 1</h2></div>\n\n  <div class=\"div\" style=\"flex-basis:160px\"><h2>item 2</h2></div>\n\n  <div class=\"div\" style=\"flex-basis:240px\"><h2>item 3</h2></div>\n</div>\n```\n\n##### 5. flex\n\n> flex 属性是 flex-grow、flex-shrink 和 flex-basis 三属性的简写总和.\n\n##### 6. align-self\n\n> align-self 属性允许 item 有自己独特的在交叉轴上的对齐方式，它有六个可能的值。默认值为 auto\n\n- auto：和父元素 align-self 的值一致\n\n- flex-start：顶端对齐\n\n- flex-end：底部对齐\n\n- center：竖直方向上居中对齐\n\n- baseline：item 第一行文字的底部对齐\n\n- stretch：当 item 未设置高度时，item 将和容器等高对齐","clickCount":99,"date":"2019-09-11T14:41:41.695Z"},{"_id":"5d7902aa7a3a8c1ea4648cda","title":"CSS学习-标签显示模式","introduce":"常见的块级元素有 h1 ~ h6 div ul ol li等，其中div 是最典型的块元素","type":"Css","content_html":"<h1><a id=\"centerCSScenter_0\"></a><center>CSS学习-标签显示模式</center></h1>\n<h3><a id=\"_2\"></a>块级元素</h3>\n<p>常见的块级元素有 h1 ~ h6 div ul ol li等，其中div 是最典型的块元素</p>\n<blockquote>\n<p>特点：</p>\n</blockquote>\n<ul>\n<li>总是从新行开始</li>\n<li>高度、行高、以及内外边距都可以控制</li>\n<li>宽度默认是容器的100%</li>\n<li>可以容纳行内元素和其他块元素</li>\n</ul>\n<h3><a id=\"_11\"></a>行内元素</h3>\n<p>常见的行内元素有 a strong b em i del s ins u span等，其中span 是最典型的行内元素</p>\n<blockquote>\n<p>特点：</p>\n</blockquote>\n<ul>\n<li>和相邻<em>行内元素</em>在同一行</li>\n<li>高、宽无效，但可设置水平方向和内外边距，垂直方向无效</li>\n<li>宽度默认是其内容本身的宽度</li>\n<li>只能容纳文本或其他行内元素（a特殊）</li>\n</ul>\n<blockquote>\n<p>注意:</p>\n</blockquote>\n<ol>\n<li>只有文字才能组成段落，因此*** p 里面不能放块级元素*** ，同理h1 ~ h6 dt等都是文字块级元素，同样不能放块级元素</li>\n<li>链接里边不能再放链接（a）</li>\n</ol>\n<h3><a id=\"inlineblock_23\"></a>行内块元素（inline-block）</h3>\n<p>在行内元素中有几个特殊的标签— img 、input 、 td ,可以对其设置宽高和对齐属性</p>\n<blockquote>\n<p>特点：</p>\n</blockquote>\n<ul>\n<li>和相邻行内元素（行内块）在同一行，但是之间会有空白缝隙</li>\n<li>宽度默认是其内容本身的宽度</li>\n<li>高度、行高、内外边距都可以控制</li>\n</ul>\n<h3><a id=\"display_31\"></a>标签显示模式转换（display）</h3>\n<p>块转行内：display: inline;<br />\n行内转块：display: block;<br />\n块、行内元素转换为行内块：display: inline-block;</p>\n","content_md":"# <center>CSS学习-标签显示模式</center>\n\n### 块级元素\n常见的块级元素有 h1 ~ h6 div ul ol li等，其中div 是最典型的块元素\n \n > 特点：\n - 总是从新行开始\n -  高度、行高、以及内外边距都可以控制\n -  宽度默认是容器的100%\n -  可以容纳行内元素和其他块元素\n\n### 行内元素\n常见的行内元素有 a strong b em i del s ins u span等，其中span 是最典型的行内元素\n \n > 特点：\n - 和相邻*行内元素*在同一行\n -  高、宽无效，但可设置水平方向和内外边距，垂直方向无效\n -  宽度默认是其内容本身的宽度\n -  只能容纳文本或其他行内元素（a特殊）\n >注意:\n 1. 只有文字才能组成段落，因此*** p 里面不能放块级元素*** ，同理h1 ~ h6 dt等都是文字块级元素，同样不能放块级元素\n 2. 链接里边不能再放链接（a）\n\n### 行内块元素（inline-block）\n在行内元素中有几个特殊的标签--- img 、input 、 td ,可以对其设置宽高和对齐属性\n \n > 特点：\n - 和相邻行内元素（行内块）在同一行，但是之间会有空白缝隙\n -  宽度默认是其内容本身的宽度\n -  高度、行高、内外边距都可以控制\n\n### 标签显示模式转换（display）\n块转行内：display: inline;\n行内转块：display: block;\n块、行内元素转换为行内块：display: inline-block;","clickCount":99,"date":"2019-09-11T14:40:18.621Z"},{"_id":"5d790826dcac1e15e4ab909e","title":"CSS学习-选择器","introduce":"链接伪类选择器(a标签)...","type":"Css","content_html":"<div class=\"hljs-center\">\n<h1><a id=\"CSS_2\"></a>CSS学习-选择器</h1>\n</div>\n<hr />\n<h3><a id=\"a_9\"></a>链接伪类选择器(a标签)</h3>\n<ul>\n<li>:link</li>\n<li>:visited</li>\n<li>:hove(最常用)</li>\n<li>:active</li>\n</ul>\n<pre><code class=\"lang-style\">    a: hove{\n        color: red;\n    }\n</code></pre>\n<!--more-->\n<hr />\n<h3><a id=\"_24\"></a>结构伪类选择器</h3>\n<ul>\n<li>:first-child</li>\n<li>:last-child</li>\n<li>:nth-child(n):匹配其父元素的第n个子元素</li>\n<li>:nth-last-child(n):从最后一个子元素开始数</li>\n</ul>\n<pre><code class=\"lang-style\">    li:nth-child(9){}   /* 匹配第9个子元素 */\n    li:nth-child(even){}   /* 匹配所有的偶数位子元素 */\n    li:nth-child(odd){}   /* 匹配所有的奇数位子元素 */\n    li:nth-child(2n){}   /* 匹配偶数位 */\n    li:nth-child(2n+1){}   /* 匹配奇数位 */\n</code></pre>\n<hr />\n<h3><a id=\"target_38\"></a>目标伪类选择器（:target）</h3>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>目录<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#life\"</span>&gt;</span>1个人生活<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#experience\"</span>&gt;</span>2人生经历<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"life\"</span>&gt;</span>个人生活<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"experience\"</span>&gt;</span>人生经历<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n</code></div></pre>\n<pre><code class=\"lang-style\">:target{\n    color: red;\n}\n</code></pre>\n<h3><a id=\"_53\"></a>属性选择器</h3>\n<p>选取标签带有某些特殊属性的选择器</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th style=\"text-align:center\">示例</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E[attr]</td>\n<td style=\"text-align:center\">div[title]</td>\n<td>带有title的div</td>\n</tr>\n<tr>\n<td>E[attr=val]</td>\n<td style=\"text-align:center\">div[title=first]</td>\n<td>带有title=&quot;first&quot;的div</td>\n</tr>\n<tr>\n<td>E[attr*=val]</td>\n<td style=\"text-align:center\">div[title*=first]</td>\n<td>带有title属性***包含***&quot;first&quot;的div</td>\n</tr>\n<tr>\n<td>E[attr^=val]</td>\n<td style=\"text-align:center\">div[title^=first]</td>\n<td>带有title属性以&quot;first&quot;***开始***的div</td>\n</tr>\n<tr>\n<td>E[attr$=val]</td>\n<td style=\"text-align:center\">div[title$=first]</td>\n<td>带有title属性以&quot;first&quot;***结尾***的div</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"_64\"></a>伪元素选择器</h3>\n<table>\n<thead>\n<tr>\n<th>示例</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>p::first-letter</td>\n<td>选择p标签内的第一个字</td>\n</tr>\n<tr>\n<td>p::first-line</td>\n<td>选择p标签内的第一行</td>\n</tr>\n<tr>\n<td>p::selection</td>\n<td>选择p标签内选中的文字</td>\n</tr>\n<tr>\n<td>div::before</td>\n<td>在div的内部前面插入</td>\n</tr>\n<tr>\n<td>div::after</td>\n<td>在div的内部后面插入</td>\n</tr>\n</tbody>\n</table>\n","content_md":"::: hljs-center\n\n# CSS学习-选择器\n\n:::\n\n\n---\n\n### 链接伪类选择器(a标签)\n- :link\n- :visited\n- :hove(最常用)\n- :active\n``` style\n    a: hove{\n        color: red;\n    }\n```\n\n<!--more-->\n\n---\n\n### 结构伪类选择器\n- :first-child\n- :last-child\n- :nth-child(n):匹配其父元素的第n个子元素\n- :nth-last-child(n):从最后一个子元素开始数\n``` style\n    li:nth-child(9){}   /* 匹配第9个子元素 */\n    li:nth-child(even){}   /* 匹配所有的偶数位子元素 */\n    li:nth-child(odd){}   /* 匹配所有的奇数位子元素 */\n    li:nth-child(2n){}   /* 匹配偶数位 */\n    li:nth-child(2n+1){}   /* 匹配奇数位 */\n```\n\n---\n### 目标伪类选择器（:target）\n``` html\n<h2>目录</h2>\n<a href=\"#life\">1个人生活</a>\n<a href=\"#experience\">2人生经历</a>\n<h3 id=\"life\">个人生活</h3>\n<h3 id=\"experience\">人生经历</h3>\n```\n``` style\n:target{\n    color: red;\n}\n```\n\n\n### 属性选择器\n 选取标签带有某些特殊属性的选择器\n\n选择器|示例|含义\n--|:--:|--\nE[attr]|div[title]|带有title的div\nE[attr=val]|div[title=first]|带有title=\"first\"的div\nE[attr\\*=val]|div[title\\*=first]|带有title属性***包含***\"first\"的div\nE[attr^=val]|div[title^=first]|带有title属性以\"first\"***开始***的div\nE[attr\\$=val]|div[title\\$=first]|带有title属性以\"first\"***结尾***的div\n\n### 伪元素选择器\n示例|含义\n--|--\np::first-letter|选择p标签内的第一个字\np::first-line|选择p标签内的第一行\np::selection|选择p标签内选中的文字\ndiv::before|在div的内部前面插入\ndiv::after|在div的内部后面插入","clickCount":99,"date":"2019-09-11T14:43:50.105Z"},{"_id":"5d79085edcac1e15e4ab90a0","title":"插入排序算法","introduce":"假设手中有一张牌，在摸第二张牌时开始将牌进行从小到大排序（顺序）...","type":"Javascript","content_html":"<div class=\"hljs-center\">\n<h2><a id=\"_2\"></a>插入排序算法</h2>\n</div>\n<h3><a id=\"_8\"></a>插入排序算法(模拟摸牌)</h3>\n<blockquote>\n<p>要求：假设手中有一张牌，在摸第二张牌时开始将牌进行从小到大排序（顺序）</p>\n</blockquote>\n<!--more-->\n<pre><code class=\"lang-\">  实现分析：\n  1. 将当前牌跟之前的手中牌从后往前开始逐一比较\n  2. 当当前牌小于前面的正在比较的手中牌时，将这一手中牌往后移一位\n  3. 当当前牌大于或等于正在比较的手中牌时停止比较并将当前牌插入到上一比较的手中牌原来的位置（也可以说是正在比较的手中牌的下一个位置）\n</code></pre>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">// 实现代码（js）</span>\n<span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">1</span>]\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt; arr.length; i++) {\n  <span class=\"hljs-keyword\">let</span> cur = arr[i] <span class=\"hljs-comment\">//当前牌</span>\n  <span class=\"hljs-keyword\">let</span> j = i - <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//摸之前手牌数</span>\n\n  <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[j] &gt; cur) {\n    arr[j + <span class=\"hljs-number\">1</span>] = arr[j]\n    j = j - <span class=\"hljs-number\">1</span>\n  }\n  arr[j + <span class=\"hljs-number\">1</span>] = cur\n}\n<span class=\"hljs-built_in\">console</span>.log(arr)\n</code></div></pre>\n","content_md":"::: hljs-center\n\n## 插入排序算法\n\n:::\n\n\n\n### 插入排序算法(模拟摸牌)\n\n> 要求：假设手中有一张牌，在摸第二张牌时开始将牌进行从小到大排序（顺序）\n\n<!--more-->\n\n```\n  实现分析：\n  1. 将当前牌跟之前的手中牌从后往前开始逐一比较\n  2. 当当前牌小于前面的正在比较的手中牌时，将这一手中牌往后移一位\n  3. 当当前牌大于或等于正在比较的手中牌时停止比较并将当前牌插入到上一比较的手中牌原来的位置（也可以说是正在比较的手中牌的下一个位置）\n```\n\n```javascript\n// 实现代码（js）\nlet arr = [8, 10, 9, 2, 5, 4, 3, 7, 11, 1]\n\nfor (let i = 1; i < arr.length; i++) {\n  let cur = arr[i] //当前牌\n  let j = i - 1 //摸之前手牌数\n\n  while (j >= 0 && arr[j] > cur) {\n    arr[j + 1] = arr[j]\n    j = j - 1\n  }\n  arr[j + 1] = cur\n}\nconsole.log(arr)\n```\n","clickCount":99,"date":"2019-09-11T14:44:46.066Z"},{"_id":"5d790954dcac1e15e4ab90a2","title":"使用kendo-ui日期选择框限制指定日期不可选","introduce":"使用kendo-ui日期选择框限制指定日期不可选...","type":"Javascript","content_html":"<div class=\"hljs-center\">\n<h2><a id=\"kendoui_2\"></a>使用kendo-ui日期选择框限制指定日期不可选</h2>\n</div>\n<hr />\n<p>需求分析:</p>\n<blockquote>\n<ol>\n<li>限制双休日日期不可选</li>\n<li>假期日不可选</li>\n<li>三个工作日后的日期不可选,工作日需排除双休日和假期日</li>\n</ol>\n</blockquote>\n<p>使用kendo-ui可以完美实现这些要求，但是使用过程中有好多坑，不过参照我下面的写法就没问题，话不多说，直接上代码吧</p>\n<blockquote>\n<p>首先，创建一个输入框用于kendo日期控件初始化日期选择框</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-html\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"date\"</span>&gt;</span>\n</code></div></pre>\n<blockquote>\n<p>引入kendo-ui,由于kendo-ui是依赖于jQuery的，所以还得先引入jQuery</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    &lt;script src=<span class=\"hljs-string\">\"/js/jquery.min.js\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n    &lt;script type=<span class=\"hljs-string\">\"text/javascript\"</span> src=<span class=\"hljs-string\">\"/js/kendo.all.min.js\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></div></pre>\n<blockquote>\n<p>定义假期日数组,这个假期日不是固定的，可以由用户维护，然后通过ajax请求获取，这里为了方便演示将其定义为固定数组</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    <span class=\"hljs-keyword\">let</span> Holiday = [<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">\"2019-03-18\"</span>),<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">\"2019-03-19\"</span>),<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">\"2019-03-20\"</span>),<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">\"2019-03-21\"</span>),<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-string\">\"2019-03-22\"</span>)]\n</code></div></pre>\n<blockquote>\n<p>初始化十日内的双休日+假期日，这里为什么只选取十日内的双休日呢，因为在未来的三个工作日之内假期日加上双休日基本不会出现十日以上的情况，这个日期集越小性能越好，所以无需定义更多，当然这里可以根据实际情况多定义几天，但强烈不建议定义整年的双休日，一是完全没必要，二是极其影响性能</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    getHoliAndWeekendDay: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-comment\">//定义10天内所有的日期</span>\n        <span class=\"hljs-keyword\">let</span> Days = [<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(),\n                    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">1</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>),\n                    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">2</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>),\n                    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">3</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>),\n                    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">4</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>),\n                    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">5</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>),\n                    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">6</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>),\n                    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>),\n                    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">8</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>),\n                    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">9</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>)]\n\n        <span class=\"hljs-comment\">//定义周末日期数组</span>\n        <span class=\"hljs-keyword\">let</span> WeekendDay = []\n\n        <span class=\"hljs-comment\">//判断日期是否为周末，是的话添加到周末日期数组</span>\n        $.each(Days,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">index,item</span>)</span>{\n            <span class=\"hljs-keyword\">if</span>(item.getDay()==<span class=\"hljs-number\">0</span> || item.getDay()==<span class=\"hljs-number\">6</span>){\n                WeekendDay.push(item)\n            }\n        })\n\n        <span class=\"hljs-comment\">//将周末日期和假期日合并返回</span>\n        <span class=\"hljs-keyword\">return</span> WeekendDay.concat(Holiday)\n    }\n\n</code></div></pre>\n<blockquote>\n<p>定义compareDates方法用于判断日期是否是同一天，只判断年月日是否相同</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    compareDates: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">date, dates</span>) </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; dates.length; i++) {\n            <span class=\"hljs-keyword\">if</span> (dates[i].getDate() == date.getDate() &amp;&amp;\n                dates[i].getMonth() == date.getMonth() &amp;&amp;\n                dates[i].getYear() == date.getYear()) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n            }\n        }\n    }\n</code></div></pre>\n<blockquote>\n<p>获取三个工作日内的最大日期</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    getMaxDate: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-comment\">//设置最大日期初始值(第3天)</span>\n        <span class=\"hljs-keyword\">let</span> MaxDate = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">3</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>)\n\n        <span class=\"hljs-comment\">//三个工作日日期数组初始值(先假定未来三天内全是工作日)</span>\n        <span class=\"hljs-keyword\">let</span> workDays = [<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()),<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">1</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>),<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime() + <span class=\"hljs-number\">2</span>*<span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>)]\n\n        <span class=\"hljs-comment\">//获取假期日+周末日期</span>\n        <span class=\"hljs-keyword\">let</span> holiDays = getHoliAndWeekendDay()\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i =<span class=\"hljs-number\">0</span>;i&lt;workDays.length;i++){\n            <span class=\"hljs-comment\">//判断工作日是否为假期日或者双休日，是的话最大日期加一天</span>\n            <span class=\"hljs-keyword\">if</span>(compareDates(workDays[i],holiDays)){\n                MaxDate = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(MaxDate.getTime() + <span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>)\n            }\n            <span class=\"hljs-comment\">//循环判断最新的最大日期是否为假期日或者双休日，是的话最大日期再加一天，直到最大日期不是假期日和双休日则跳出循环</span>\n            <span class=\"hljs-keyword\">while</span>(compareDates(MaxDate,holiDays)){\n                MaxDate = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(MaxDate.getTime() + <span class=\"hljs-number\">24</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>)\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> MaxDate\n    }\n</code></div></pre>\n<blockquote>\n<p>初始化kendo-ui日期控件</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    initKendoDateControl: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) </span>{\n        target.kendoDatePicker({\n        <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">\"dd MMM yyyy\"</span>,\n        <span class=\"hljs-attr\">parseFormats</span>: [<span class=\"hljs-string\">\"yyyy-MM-dd\"</span>],\n        <span class=\"hljs-attr\">disableDates</span>:<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">date</span>)</span>{        <span class=\"hljs-comment\">//配置禁止选择指定日期</span>\n            <span class=\"hljs-keyword\">let</span> isHoliDay = <span class=\"hljs-literal\">false</span>\n            <span class=\"hljs-keyword\">let</span> holiDays = getHoliAndWeekendDay()   <span class=\"hljs-comment\">//假期日+周末日期</span>\n            <span class=\"hljs-keyword\">if</span> (date &amp;&amp; compareDates(date,holiDays)){\n                isHoliDay = <span class=\"hljs-literal\">true</span>\n            }\n            <span class=\"hljs-keyword\">return</span> isHoliDay\n        },\n        <span class=\"hljs-attr\">max</span>:getMaxDate()        <span class=\"hljs-comment\">//定义最大可选日期，即第三个工作日为最大日期，第三个工作日后的所有日期不可宣不可见</span>\n        })\n        .data(<span class=\"hljs-string\">'kendoDatePicker'</span>).enable(<span class=\"hljs-literal\">true</span>)\n\n        <span class=\"hljs-comment\">// 失去焦点时判断日期合法性</span>\n        target.on(<span class=\"hljs-string\">'blur'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n            $(<span class=\"hljs-keyword\">this</span>).kendoDateCheck()\n        })\n    }\n</code></div></pre>\n<blockquote>\n<p>初始化日期输入框</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    initKendoDateControl($(<span class=\"hljs-string\">\"#date\"</span>))\n\n    <span class=\"hljs-comment\">//将日期输入框设置成只可点选不可输入</span>\n    $(<span class=\"hljs-string\">\"#date\"</span>).data(<span class=\"hljs-string\">\"kendoDatePicker\"</span>).element[<span class=\"hljs-number\">0</span>].disabled=<span class=\"hljs-literal\">true</span>\n</code></div></pre>\n","content_md":"::: hljs-center\n\n## 使用kendo-ui日期选择框限制指定日期不可选\n\n:::\n\n---\n\n需求分析:\n\n>1. 限制双休日日期不可选\n>2. 假期日不可选\n>3. 三个工作日后的日期不可选,工作日需排除双休日和假期日\n\n使用kendo-ui可以完美实现这些要求，但是使用过程中有好多坑，不过参照我下面的写法就没问题，话不多说，直接上代码吧\n\n\n> 首先，创建一个输入框用于kendo日期控件初始化日期选择框\n``` html\n    <input id=\"date\">\n```\n\n> 引入kendo-ui,由于kendo-ui是依赖于jQuery的，所以还得先引入jQuery\n``` javascript\n    <script src=\"/js/jquery.min.js\"></script>\n    <script type=\"text/javascript\" src=\"/js/kendo.all.min.js\"></script>\n```\n\n> 定义假期日数组,这个假期日不是固定的，可以由用户维护，然后通过ajax请求获取，这里为了方便演示将其定义为固定数组\n\n``` javascript\n    let Holiday = [new Date(\"2019-03-18\"),new Date(\"2019-03-19\"),new Date(\"2019-03-20\"),new Date(\"2019-03-21\"),new Date(\"2019-03-22\")]\n```\n\n> 初始化十日内的双休日+假期日，这里为什么只选取十日内的双休日呢，因为在未来的三个工作日之内假期日加上双休日基本不会出现十日以上的情况，这个日期集越小性能越好，所以无需定义更多，当然这里可以根据实际情况多定义几天，但强烈不建议定义整年的双休日，一是完全没必要，二是极其影响性能\n\n``` javascript\n    getHoliAndWeekendDay: function(){\n        //定义10天内所有的日期\n        let Days = [new Date(),\n                    new Date(new Date().getTime() + 1*24*60*60*1000),\n                    new Date(new Date().getTime() + 2*24*60*60*1000),\n                    new Date(new Date().getTime() + 3*24*60*60*1000),\n                    new Date(new Date().getTime() + 4*24*60*60*1000),\n                    new Date(new Date().getTime() + 5*24*60*60*1000),\n                    new Date(new Date().getTime() + 6*24*60*60*1000),\n                    new Date(new Date().getTime() + 7*24*60*60*1000),\n                    new Date(new Date().getTime() + 8*24*60*60*1000),\n                    new Date(new Date().getTime() + 9*24*60*60*1000)]\n\n        //定义周末日期数组\n        let WeekendDay = []\n\n        //判断日期是否为周末，是的话添加到周末日期数组\n        $.each(Days,function(index,item){\n            if(item.getDay()==0 || item.getDay()==6){\n                WeekendDay.push(item)\n            }\n        })\n\n        //将周末日期和假期日合并返回\n        return WeekendDay.concat(Holiday)\n    }\n\n```\n\n> 定义compareDates方法用于判断日期是否是同一天，只判断年月日是否相同\n``` javascript\n    compareDates: function(date, dates) {\n        for (let i = 0; i < dates.length; i++) {\n            if (dates[i].getDate() == date.getDate() &&\n                dates[i].getMonth() == date.getMonth() &&\n                dates[i].getYear() == date.getYear()) {\n                return true\n            }\n        }\n    }\n```\n\n> 获取三个工作日内的最大日期\n``` javascript\n    getMaxDate: function(){\n        //设置最大日期初始值(第3天)\n        let MaxDate = new Date(new Date().getTime() + 3*24*60*60*1000)\n\n        //三个工作日日期数组初始值(先假定未来三天内全是工作日)\n        let workDays = [new Date(new Date()),new Date(new Date().getTime() + 1*24*60*60*1000),new Date(new Date().getTime() + 2*24*60*60*1000)]\n\n        //获取假期日+周末日期\n        let holiDays = getHoliAndWeekendDay()\n        for(let i =0;i<workDays.length;i++){\n            //判断工作日是否为假期日或者双休日，是的话最大日期加一天\n            if(compareDates(workDays[i],holiDays)){\n                MaxDate = new Date(MaxDate.getTime() + 24*60*60*1000)\n            }\n            //循环判断最新的最大日期是否为假期日或者双休日，是的话最大日期再加一天，直到最大日期不是假期日和双休日则跳出循环\n            while(compareDates(MaxDate,holiDays)){\n                MaxDate = new Date(MaxDate.getTime() + 24*60*60*1000)\n            }\n        }\n        return MaxDate\n    }\n```\n\n> 初始化kendo-ui日期控件\n``` javascript\n    initKendoDateControl: function (target) {\n        target.kendoDatePicker({\n        format: \"dd MMM yyyy\",\n        parseFormats: [\"yyyy-MM-dd\"],\n        disableDates:function(date){        //配置禁止选择指定日期\n            let isHoliDay = false\n            let holiDays = getHoliAndWeekendDay()   //假期日+周末日期\n            if (date && compareDates(date,holiDays)){\n                isHoliDay = true\n            }\n            return isHoliDay\n        },\n        max:getMaxDate()        //定义最大可选日期，即第三个工作日为最大日期，第三个工作日后的所有日期不可宣不可见\n        })\n        .data('kendoDatePicker').enable(true)\n\n        // 失去焦点时判断日期合法性\n        target.on('blur', function () {\n            $(this).kendoDateCheck()\n        })\n    }\n```\n\n> 初始化日期输入框\n``` javascript\n    initKendoDateControl($(\"#date\"))\n\n    //将日期输入框设置成只可点选不可输入\n    $(\"#date\").data(\"kendoDatePicker\").element[0].disabled=true\n```\n","clickCount":99,"date":"2019-09-11T14:48:52.219Z"},{"_id":"5d7c997b3a94722f647c5855","title":"《JavaScript高级程序设计》读书笔记(一)","introduce":"记录《JavaScript高级程序设计》这本书的要点，第一篇，持续更新","type":"Javascript","content_html":"<h1><a id=\"1__0\"></a>1 基本概念</h1>\n<h2><a id=\"11__2\"></a>1.1 语法</h2>\n<pre><code>ECMAScript 的语法大量借鉴了C 及其他类C 语言（如Java 和Perl）的语法。\n熟悉这些语言的开发人员在接受ECMAScript 更加宽松的语法时，一定会有一种轻松自在的感觉。\n即使没有其他编程语言基础，JavaScript仍然易上手。\n</code></pre>\n<h3><a id=\"111__8\"></a>1.1.1 区分大小写</h3>\n<pre><code>ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n变量名test 和变量名Test 分别表示两个不同的变量。\n</code></pre>\n<h3><a id=\"112__13\"></a>1.1.2 标识符</h3>\n<pre><code>标识符，就是指变量、函数、属性的名字，或者函数的参数，规则：\n1. 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）\n2. 其他字符可以是字母、下划线、美元符号或数字\n3. 不允许是关键字、保留字、true、false和null\n</code></pre>\n<p>ECMAScript 标识符采用驼峰大小写格式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> myBlog\n<span class=\"hljs-keyword\">var</span> doSomethingImportant\n</code></div></pre>\n<h3><a id=\"113__27\"></a>1.1.3 注释</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">//单行注释</span>\n\n<span class=\"hljs-comment\">/*\n * 这是一个多行\n * （块级）注释\n */</span>\n</code></div></pre>\n<pre><code>虽然上面多行注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性\n</code></pre>\n<h3><a id=\"114__40\"></a>1.1.4 语句</h3>\n<p>ECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> sum = a + b <span class=\"hljs-comment\">// 即使没有分号也是有效的语句——不推荐</span>\n<span class=\"hljs-keyword\">var</span> diff = a - b <span class=\"hljs-comment\">// 有效的语句——推荐</span>\n</code></div></pre>\n<pre><code>加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了\n</code></pre>\n<p>尽量始终在控制语句中使用代码块——即使代码块中只有一条语句</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">// 有效但容易出错，不要使用</span>\n<span class=\"hljs-keyword\">if</span> (test) \n  alert(test)\n\n<span class=\"hljs-comment\">// 推荐使用</span>\n<span class=\"hljs-keyword\">if</span> (test) {\n  alert(test)\n}\n</code></div></pre>\n<pre><code>在控制语句中使用代码块可以让编码意图更加清晰，而且也能降低修改代码时出错的几率\n</code></pre>\n<h2><a id=\"12__66\"></a>1.2 关键字和保留字</h2>\n<p>ECMAScript 的全部关键字</p>\n<blockquote>\n<p>break do instanceof typeof case else new var<br />\ncatch finally return void continue for switch while<br />\ndebugger function this with default if throw delete in try</p>\n</blockquote>\n<p>保留字：</p>\n<blockquote>\n<p>abstract enum int short boolean export interface static<br />\nbyte extends long super char final native synchronized<br />\nclass float package throws const goto private transient<br />\ndebugger implements protected volatile double import public</p>\n</blockquote>\n<h2><a id=\"13__81\"></a>1.3 变量</h2>\n<p>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。</p>\n<pre><code>可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：\n</code></pre>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">'hi'</span>,\n    found = <span class=\"hljs-literal\">false</span>,\n    age = <span class=\"hljs-number\">29</span>\n</code></div></pre>\n<h2><a id=\"14__93\"></a>1.4 数据类型</h2>\n<p>5 种简单数据类型（也称为基本数据类型）：</p>\n<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n</ul>\n<p>1 种复杂数据类型: Object</p>\n<h3><a id=\"141_typeof__105\"></a>1.4.1 typeof 操作符</h3>\n<p>typeof——用来检测给定变量的数据类型的操作符</p>\n<ul>\n<li>“undefined”——如果这个值未定义</li>\n<li>“boolean”——如果这个值是布尔值</li>\n<li>“string”——如果这个值是字符串</li>\n<li>“number”——如果这个值是数值</li>\n<li>“object”——如果这个值是对象或 null</li>\n<li>“function”——如果这个值是函数</li>\n</ul>\n<p>例：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">'some string'</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> (message)) <span class=\"hljs-comment\">// \"string\"</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> message) <span class=\"hljs-comment\">// \"string\"</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">95</span>) <span class=\"hljs-comment\">// \"number\"</span>\n</code></div></pre>\n<pre><code>注意：typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的\n</code></pre>\n<h3><a id=\"142_Undefined__127\"></a>1.4.2 Undefined 类型</h3>\n<p>Undefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时，<br />\n这个变量的值就是 undefined，例如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> message\n<span class=\"hljs-built_in\">console</span>.log(message == <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">//true</span>\n</code></div></pre>\n<h3><a id=\"143_Null__137\"></a>1.4.3 Null 类型</h3>\n<p>Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回&quot;object&quot;的原因，如下面的例子所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> car = <span class=\"hljs-literal\">null</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> car) <span class=\"hljs-comment\">// \"object\"</span>\n</code></div></pre>\n<p>实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-literal\">null</span> == <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">//true</span>\n</code></div></pre>\n<h3><a id=\"144_Boolean__152\"></a>1.4.4 Boolean 类型</h3>\n<p>该类型只有两个字面值：true 和 false。<br />\n虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值 等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()，如下例所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">'Hello world!'</span>\n<span class=\"hljs-keyword\">var</span> messageAsBoolean = <span class=\"hljs-built_in\">Boolean</span>(message)\n<span class=\"hljs-built_in\">console</span>.log(messageAsBoolean) <span class=\"hljs-comment\">//true</span>\n</code></div></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">转换为 true 的值</th>\n<th style=\"text-align:center\">转换为 false 的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">任何非空字符串</td>\n<td style=\"text-align:center\">‘’(空字符串)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Number</td>\n<td style=\"text-align:center\">任何非零数字值（包括无穷大）</td>\n<td style=\"text-align:center\">0 和 NaN</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Undefined</td>\n<td style=\"text-align:center\">不适合这种规则</td>\n<td style=\"text-align:center\">undefined</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"145_Number__170\"></a>1.4.5 Number 类型</h3>\n<p>Number 类型使用 IEEE754 格式来表示 整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。</p>\n<h4><a id=\"1__174\"></a>1. 浮点数值</h4>\n<p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字<br />\n由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值 转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样 地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数，如下面的例子所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> floatNum1 = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 小数点后面没有数字——解析为 1</span>\n<span class=\"hljs-keyword\">var</span> floatNum2 = <span class=\"hljs-number\">10.0</span> <span class=\"hljs-comment\">// 整数——解析为 10</span>\n</code></div></pre>\n<p>浮点数值的高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。 例如:</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">if</span> (a + b == <span class=\"hljs-number\">0.3</span>) {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'You got 0.3.'</span>)   <span class=\"hljs-comment\">// 不要做这样的测试！</span>\n}\n</code></div></pre>\n<pre><code>在这个例子中，我们测试的是两个数的和是不是等于 0.3。如果这两个数\n是 0.05和 0.25，或者是 0.15 和 0.15都不会有问题。而如前所述，如\n果这两个数是 0.1和 0.2，那么测试将无法通过。因此，永远不 要测试某\n个特定的浮点数值。\n</code></pre>\n<h4><a id=\"2__196\"></a>2. 数值范围</h4>\n<p>由于内存的限制，ECMAScript 并不能保存世界上所有的数值。ECMAScript 能够表示的小数值保 存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的 结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具 体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转 换成 Infinity（正无穷）。</p>\n<pre><code>如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，\n因为 Infinity 不是能够参与计算的数值\n</code></pre>\n<h4><a id=\"3_NaN_203\"></a>3. NaN</h4>\n<p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数 未返回数值的情况（这样就不会抛出错误了）</p>\n","content_md":"# 1 基本概念\n\n## 1.1 语法\n\n    ECMAScript 的语法大量借鉴了C 及其他类C 语言（如Java 和Perl）的语法。\n    熟悉这些语言的开发人员在接受ECMAScript 更加宽松的语法时，一定会有一种轻松自在的感觉。\n    即使没有其他编程语言基础，JavaScript仍然易上手。\n\n### 1.1.1 区分大小写\n\n    ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n    变量名test 和变量名Test 分别表示两个不同的变量。\n\n### 1.1.2 标识符\n\n    标识符，就是指变量、函数、属性的名字，或者函数的参数，规则：\n    1. 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）\n    2. 其他字符可以是字母、下划线、美元符号或数字\n    3. 不允许是关键字、保留字、true、false和null\n\nECMAScript 标识符采用驼峰大小写格式：\n\n```javascript\nvar myBlog\nvar doSomethingImportant\n```\n\n### 1.1.3 注释\n\n```javascript\n//单行注释\n\n/*\n * 这是一个多行\n * （块级）注释\n */\n```\n\n    虽然上面多行注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性\n\n### 1.1.4 语句\n\nECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示：\n\n```javascript\nvar sum = a + b // 即使没有分号也是有效的语句——不推荐\nvar diff = a - b // 有效的语句——推荐\n```\n\n    加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了\n\n尽量始终在控制语句中使用代码块——即使代码块中只有一条语句\n\n```javascript\n// 有效但容易出错，不要使用\nif (test) \n  alert(test)\n\n// 推荐使用\nif (test) {\n  alert(test)\n}\n```\n\n    在控制语句中使用代码块可以让编码意图更加清晰，而且也能降低修改代码时出错的几率\n\n## 1.2 关键字和保留字\n\nECMAScript 的全部关键字\n\n> break do instanceof typeof case else new var\n> catch finally return void continue for switch while\n> debugger function this with default if throw delete in try\n\n保留字：\n\n> abstract enum int short boolean export interface static\n> byte extends long super char final native synchronized\n> class float package throws const goto private transient\n> debugger implements protected volatile double import public\n\n## 1.3 变量\n\nECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。\n\n    可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：\n\n```javascript\nvar message = 'hi',\n    found = false,\n    age = 29\n```\n\n## 1.4 数据类型\n\n5 种简单数据类型（也称为基本数据类型）：\n\n- Undefined\n- Null\n- Boolean\n- Number\n- String\n\n1 种复杂数据类型: Object\n\n### 1.4.1 typeof 操作符\n\ntypeof——用来检测给定变量的数据类型的操作符\n\n- \"undefined\"——如果这个值未定义\n- \"boolean\"——如果这个值是布尔值\n- \"string\"——如果这个值是字符串\n- \"number\"——如果这个值是数值\n- \"object\"——如果这个值是对象或 null\n- \"function\"——如果这个值是函数\n\n例：\n\n```javascript\nvar message = 'some string'\nconsole.log(typeof (message)) // \"string\"\nconsole.log(typeof message) // \"string\"\nconsole.log(typeof 95) // \"number\"\n```\n\n    注意：typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的\n\n### 1.4.2 Undefined 类型\n\nUndefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时，\n这个变量的值就是 undefined，例如：\n\n```javascript\nvar message\nconsole.log(message == undefined) //true\n```\n\n### 1.4.3 Null 类型\n\nNull 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回\"object\"的原因，如下面的例子所示：\n\n```javascript\nvar car = null\nconsole.log(typeof car) // \"object\"\n```\n\n实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true：\n\n```javascript\nconsole.log(null == undefined) //true\n```\n\n### 1.4.4 Boolean 类型\n\n该类型只有两个字面值：true 和 false。\n虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值 等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()，如下例所示：\n\n```javascript\nvar message = 'Hello world!'\nvar messageAsBoolean = Boolean(message)\nconsole.log(messageAsBoolean) //true\n```\n\n| 数据类型  |       转换为 true 的值       | 转换为 false 的值 |\n| :-------: | :--------------------------: | :---------------: |\n|  Boolean  |             true             |       false       |\n|  String   |        任何非空字符串        |   ''(空字符串)    |\n|  Number   | 任何非零数字值（包括无穷大） |     0 和 NaN      |\n| Undefined |        不适合这种规则        |     undefined     |\n\n### 1.4.5 Number 类型\n\nNumber 类型使用 IEEE754 格式来表示 整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。\n\n#### 1. 浮点数值\n\n所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字\n由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值 转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样 地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数，如下面的例子所示：\n\n```javascript\nvar floatNum1 = 1 // 小数点后面没有数字——解析为 1\nvar floatNum2 = 10.0 // 整数——解析为 10\n```\n浮点数值的高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。 例如:\n\n```javascript\nif (a + b == 0.3) {\nconsole.log('You got 0.3.')   // 不要做这样的测试！\n}\n```\n\n    在这个例子中，我们测试的是两个数的和是不是等于 0.3。如果这两个数\n    是 0.05和 0.25，或者是 0.15 和 0.15都不会有问题。而如前所述，如\n    果这两个数是 0.1和 0.2，那么测试将无法通过。因此，永远不 要测试某\n    个特定的浮点数值。\n\n#### 2. 数值范围\n\n由于内存的限制，ECMAScript 并不能保存世界上所有的数值。ECMAScript 能够表示的小数值保 存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的 结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具 体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转 换成 Infinity（正无穷）。\n\n    如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，\n    因为 Infinity 不是能够参与计算的数值\n\n#### 3. NaN\n\nNaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数 未返回数值的情况（这样就不会抛出错误了）\n","clickCount":99,"date":"2019-09-14T07:41:47.215Z"},{"_id":"5d7f95ebee76fb15680125ae","title":"JavaScript的几个很实用的数组方法","introduce":"some方法，every方法，filter方法，map方法","type":"Javascript","content_html":"<div class=\"hljs-center\">\n<h2><a id=\"JavaScript_1\"></a>JavaScript的几个很实用的数组方法</h2>\n</div>\n<h3><a id=\"some_5\"></a><strong>some方法</strong></h3>\n<blockquote>\n<p>some(): 返回一个Boolean，判断是否有元素符合func条件</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">  <span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\n  arr.some(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">//返回结果true</span>\n</code></div></pre>\n<h3><a id=\"every_13\"></a><strong>every方法</strong></h3>\n<blockquote>\n<p>every(): 返回一个Boolean，判断每一个元素是否符合func条件</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">  <span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\n  arr.every(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">3</span>);   <span class=\"hljs-comment\">//返回结果false</span>\n  arr.every(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt;= <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">//返回结果true</span>\n</code></div></pre>\n<h3><a id=\"filter_22\"></a><strong>filter方法</strong></h3>\n<blockquote>\n<p>filter(): 返回一个符合func条件的元素数组,不改变原来数组</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">  <span class=\"hljs-keyword\">let</span> ages = [<span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">28</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">32</span>];\n  ages.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">25</span>);  <span class=\"hljs-comment\">//[28,32]</span>\n  <span class=\"hljs-built_in\">console</span>.log(ages);    <span class=\"hljs-comment\">//[23, 28, 25, 32]</span>\n</code></div></pre>\n<p>此方法非常实用，可以用于删除数组的操作，一般删除数组会用splice方法，但此方法用起来很麻烦，首先得找到索引，然后再删除，尤其在遍历删除的时候每删除一个元素，后面的元素索引就会错乱，虽然可以从后往前删，但终究麻烦，不过使用filter方法就会简单很多</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">  <span class=\"hljs-keyword\">let</span> ages = [<span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">28</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">32</span>];\n  ages.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">25</span>);  <span class=\"hljs-comment\">//删除元素不大于25的所有元素</span>\n  ages.filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">item,index</span>) =&gt;</span> (index != <span class=\"hljs-number\">2</span> &amp;&amp; index != <span class=\"hljs-number\">3</span>) );  <span class=\"hljs-comment\">//删除索引为2和3的元素</span>\n</code></div></pre>\n<h3><a id=\"map_40\"></a><strong>map方法</strong></h3>\n<blockquote>\n<p>返回一个新的array，数组元素由每一次调用函数产生结果组成</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">  <span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];\n  arr.map( <span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item + <span class=\"hljs-number\">1</span>);   <span class=\"hljs-comment\">//[2,3,4,5,6,7]</span>\n</code></div></pre>\n","content_md":"::: hljs-center\n## JavaScript的几个很实用的数组方法\n:::\n\n\n### **some方法**\n> some(): 返回一个Boolean，判断是否有元素符合func条件 \n\n```javascript\n  let arr = [1,2,3,4];\n  arr.some(item => item > 1);  //返回结果true\n``` \n\n### **every方法**\n> every(): 返回一个Boolean，判断每一个元素是否符合func条件\n\n```javascript\n  let arr = [1,2,3,4];\n  arr.every(item => item > 3);   //返回结果false\n  arr.every(item => item >= 1);  //返回结果true\n``` \n\n### **filter方法**\n\n> filter(): 返回一个符合func条件的元素数组,不改变原来数组 \n\n```javascript\n  let ages = [23, 28, 25, 32];\n  ages.filter(item => item > 25);  //[28,32]\n  console.log(ages);    //[23, 28, 25, 32]\n``` \n\n此方法非常实用，可以用于删除数组的操作，一般删除数组会用splice方法，但此方法用起来很麻烦，首先得找到索引，然后再删除，尤其在遍历删除的时候每删除一个元素，后面的元素索引就会错乱，虽然可以从后往前删，但终究麻烦，不过使用filter方法就会简单很多 \n\n```javascript\n  let ages = [23, 28, 25, 32];\n  ages.filter(item => item > 25);  //删除元素不大于25的所有元素\n  ages.filter((item,index) => (index != 2 && index != 3) );  //删除索引为2和3的元素\n```\n\n### **map方法**\n\n> 返回一个新的array，数组元素由每一次调用函数产生结果组成\n\n```javascript\n  let arr = [1, 2, 3, 4, 5, 6];\n  arr.map( item => item + 1);   //[2,3,4,5,6,7]\n```","clickCount":99,"date":"2019-10-05T15:31:00.739Z"}]}