{
  "article": {
    "_id": "5d7c997b3a94722f647c5855",
    "title": "《JavaScript高级程序设计》读书笔记(一)",
    "type": "Javascript",
    "content_html": "<h1><a id=\"1__0\"></a>1 基本概念</h1>\n<h2><a id=\"11__2\"></a>1.1 语法</h2>\n<pre><code>ECMAScript 的语法大量借鉴了C 及其他类C 语言（如Java 和Perl）的语法。\n熟悉这些语言的开发人员在接受ECMAScript 更加宽松的语法时，一定会有一种轻松自在的感觉。\n即使没有其他编程语言基础，JavaScript仍然易上手。\n</code></pre>\n<h3><a id=\"111__8\"></a>1.1.1 区分大小写</h3>\n<pre><code>ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n变量名test 和变量名Test 分别表示两个不同的变量。\n</code></pre>\n<h3><a id=\"112__13\"></a>1.1.2 标识符</h3>\n<pre><code>标识符，就是指变量、函数、属性的名字，或者函数的参数，规则：\n1. 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）\n2. 其他字符可以是字母、下划线、美元符号或数字\n3. 不允许是关键字、保留字、true、false和null\n</code></pre>\n<p>ECMAScript 标识符采用驼峰大小写格式：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> myBlog\n<span class=\"hljs-keyword\">var</span> doSomethingImportant\n</code></div></pre>\n<h3><a id=\"113__27\"></a>1.1.3 注释</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">//单行注释</span>\n\n<span class=\"hljs-comment\">/*\n * 这是一个多行\n * （块级）注释\n */</span>\n</code></div></pre>\n<pre><code>虽然上面多行注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性\n</code></pre>\n<h3><a id=\"114__40\"></a>1.1.4 语句</h3>\n<p>ECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> sum = a + b <span class=\"hljs-comment\">// 即使没有分号也是有效的语句——不推荐</span>\n<span class=\"hljs-keyword\">var</span> diff = a - b <span class=\"hljs-comment\">// 有效的语句——推荐</span>\n</code></div></pre>\n<pre><code>加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了\n</code></pre>\n<p>尽量始终在控制语句中使用代码块——即使代码块中只有一条语句</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">// 有效但容易出错，不要使用</span>\n<span class=\"hljs-keyword\">if</span> (test) \n  alert(test)\n\n<span class=\"hljs-comment\">// 推荐使用</span>\n<span class=\"hljs-keyword\">if</span> (test) {\n  alert(test)\n}\n</code></div></pre>\n<pre><code>在控制语句中使用代码块可以让编码意图更加清晰，而且也能降低修改代码时出错的几率\n</code></pre>\n<h2><a id=\"12__66\"></a>1.2 关键字和保留字</h2>\n<p>ECMAScript 的全部关键字</p>\n<blockquote>\n<p>break do instanceof typeof case else new var<br />\ncatch finally return void continue for switch while<br />\ndebugger function this with default if throw delete in try</p>\n</blockquote>\n<p>保留字：</p>\n<blockquote>\n<p>abstract enum int short boolean export interface static<br />\nbyte extends long super char final native synchronized<br />\nclass float package throws const goto private transient<br />\ndebugger implements protected volatile double import public</p>\n</blockquote>\n<h2><a id=\"13__81\"></a>1.3 变量</h2>\n<p>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。</p>\n<pre><code>可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：\n</code></pre>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">'hi'</span>,\n    found = <span class=\"hljs-literal\">false</span>,\n    age = <span class=\"hljs-number\">29</span>\n</code></div></pre>\n<h2><a id=\"14__93\"></a>1.4 数据类型</h2>\n<p>5 种简单数据类型（也称为基本数据类型）：</p>\n<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n</ul>\n<p>1 种复杂数据类型: Object</p>\n<h3><a id=\"141_typeof__105\"></a>1.4.1 typeof 操作符</h3>\n<p>typeof——用来检测给定变量的数据类型的操作符</p>\n<ul>\n<li>“undefined”——如果这个值未定义</li>\n<li>“boolean”——如果这个值是布尔值</li>\n<li>“string”——如果这个值是字符串</li>\n<li>“number”——如果这个值是数值</li>\n<li>“object”——如果这个值是对象或 null</li>\n<li>“function”——如果这个值是函数</li>\n</ul>\n<p>例：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">'some string'</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> (message)) <span class=\"hljs-comment\">// \"string\"</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> message) <span class=\"hljs-comment\">// \"string\"</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">95</span>) <span class=\"hljs-comment\">// \"number\"</span>\n</code></div></pre>\n<pre><code>注意：typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的\n</code></pre>\n<h3><a id=\"142_Undefined__127\"></a>1.4.2 Undefined 类型</h3>\n<p>Undefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时，<br />\n这个变量的值就是 undefined，例如：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> message\n<span class=\"hljs-built_in\">console</span>.log(message == <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">//true</span>\n</code></div></pre>\n<h3><a id=\"143_Null__137\"></a>1.4.3 Null 类型</h3>\n<p>Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回&quot;object&quot;的原因，如下面的例子所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> car = <span class=\"hljs-literal\">null</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> car) <span class=\"hljs-comment\">// \"object\"</span>\n</code></div></pre>\n<p>实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-literal\">null</span> == <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">//true</span>\n</code></div></pre>\n<h3><a id=\"144_Boolean__152\"></a>1.4.4 Boolean 类型</h3>\n<p>该类型只有两个字面值：true 和 false。<br />\n虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值 等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()，如下例所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">'Hello world!'</span>\n<span class=\"hljs-keyword\">var</span> messageAsBoolean = <span class=\"hljs-built_in\">Boolean</span>(message)\n<span class=\"hljs-built_in\">console</span>.log(messageAsBoolean) <span class=\"hljs-comment\">//true</span>\n</code></div></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">转换为 true 的值</th>\n<th style=\"text-align:center\">转换为 false 的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">任何非空字符串</td>\n<td style=\"text-align:center\">‘’(空字符串)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Number</td>\n<td style=\"text-align:center\">任何非零数字值（包括无穷大）</td>\n<td style=\"text-align:center\">0 和 NaN</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Undefined</td>\n<td style=\"text-align:center\">不适合这种规则</td>\n<td style=\"text-align:center\">undefined</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"145_Number__170\"></a>1.4.5 Number 类型</h3>\n<p>Number 类型使用 IEEE754 格式来表示 整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。</p>\n<h4><a id=\"1__174\"></a>1. 浮点数值</h4>\n<p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字<br />\n由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值 转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样 地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数，如下面的例子所示：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> floatNum1 = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 小数点后面没有数字——解析为 1</span>\n<span class=\"hljs-keyword\">var</span> floatNum2 = <span class=\"hljs-number\">10.0</span> <span class=\"hljs-comment\">// 整数——解析为 10</span>\n</code></div></pre>\n<p>浮点数值的高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。 例如:</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">if</span> (a + b == <span class=\"hljs-number\">0.3</span>) {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'You got 0.3.'</span>)   <span class=\"hljs-comment\">// 不要做这样的测试！</span>\n}\n</code></div></pre>\n<pre><code>在这个例子中，我们测试的是两个数的和是不是等于 0.3。如果这两个数\n是 0.05和 0.25，或者是 0.15 和 0.15都不会有问题。而如前所述，如\n果这两个数是 0.1和 0.2，那么测试将无法通过。因此，永远不 要测试某\n个特定的浮点数值。\n</code></pre>\n<h4><a id=\"2__196\"></a>2. 数值范围</h4>\n<p>由于内存的限制，ECMAScript 并不能保存世界上所有的数值。ECMAScript 能够表示的小数值保 存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的 结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具 体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转 换成 Infinity（正无穷）。</p>\n<pre><code>如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，\n因为 Infinity 不是能够参与计算的数值\n</code></pre>\n<h4><a id=\"3_NaN_203\"></a>3. NaN</h4>\n<p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数 未返回数值的情况（这样就不会抛出错误了）</p>\n",
    "content_md": "# 1 基本概念\n\n## 1.1 语法\n\n    ECMAScript 的语法大量借鉴了C 及其他类C 语言（如Java 和Perl）的语法。\n    熟悉这些语言的开发人员在接受ECMAScript 更加宽松的语法时，一定会有一种轻松自在的感觉。\n    即使没有其他编程语言基础，JavaScript仍然易上手。\n\n### 1.1.1 区分大小写\n\n    ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。\n    变量名test 和变量名Test 分别表示两个不同的变量。\n\n### 1.1.2 标识符\n\n    标识符，就是指变量、函数、属性的名字，或者函数的参数，规则：\n    1. 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）\n    2. 其他字符可以是字母、下划线、美元符号或数字\n    3. 不允许是关键字、保留字、true、false和null\n\nECMAScript 标识符采用驼峰大小写格式：\n\n```javascript\nvar myBlog\nvar doSomethingImportant\n```\n\n### 1.1.3 注释\n\n```javascript\n//单行注释\n\n/*\n * 这是一个多行\n * （块级）注释\n */\n```\n\n    虽然上面多行注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性\n\n### 1.1.4 语句\n\nECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示：\n\n```javascript\nvar sum = a + b // 即使没有分号也是有效的语句——不推荐\nvar diff = a - b // 有效的语句——推荐\n```\n\n    加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了\n\n尽量始终在控制语句中使用代码块——即使代码块中只有一条语句\n\n```javascript\n// 有效但容易出错，不要使用\nif (test) \n  alert(test)\n\n// 推荐使用\nif (test) {\n  alert(test)\n}\n```\n\n    在控制语句中使用代码块可以让编码意图更加清晰，而且也能降低修改代码时出错的几率\n\n## 1.2 关键字和保留字\n\nECMAScript 的全部关键字\n\n> break do instanceof typeof case else new var\n> catch finally return void continue for switch while\n> debugger function this with default if throw delete in try\n\n保留字：\n\n> abstract enum int short boolean export interface static\n> byte extends long super char final native synchronized\n> class float package throws const goto private transient\n> debugger implements protected volatile double import public\n\n## 1.3 变量\n\nECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。\n\n    可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：\n\n```javascript\nvar message = 'hi',\n    found = false,\n    age = 29\n```\n\n## 1.4 数据类型\n\n5 种简单数据类型（也称为基本数据类型）：\n\n- Undefined\n- Null\n- Boolean\n- Number\n- String\n\n1 种复杂数据类型: Object\n\n### 1.4.1 typeof 操作符\n\ntypeof——用来检测给定变量的数据类型的操作符\n\n- \"undefined\"——如果这个值未定义\n- \"boolean\"——如果这个值是布尔值\n- \"string\"——如果这个值是字符串\n- \"number\"——如果这个值是数值\n- \"object\"——如果这个值是对象或 null\n- \"function\"——如果这个值是函数\n\n例：\n\n```javascript\nvar message = 'some string'\nconsole.log(typeof (message)) // \"string\"\nconsole.log(typeof message) // \"string\"\nconsole.log(typeof 95) // \"number\"\n```\n\n    注意：typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的\n\n### 1.4.2 Undefined 类型\n\nUndefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时，\n这个变量的值就是 undefined，例如：\n\n```javascript\nvar message\nconsole.log(message == undefined) //true\n```\n\n### 1.4.3 Null 类型\n\nNull 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回\"object\"的原因，如下面的例子所示：\n\n```javascript\nvar car = null\nconsole.log(typeof car) // \"object\"\n```\n\n实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true：\n\n```javascript\nconsole.log(null == undefined) //true\n```\n\n### 1.4.4 Boolean 类型\n\n该类型只有两个字面值：true 和 false。\n虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值 等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()，如下例所示：\n\n```javascript\nvar message = 'Hello world!'\nvar messageAsBoolean = Boolean(message)\nconsole.log(messageAsBoolean) //true\n```\n\n| 数据类型  |       转换为 true 的值       | 转换为 false 的值 |\n| :-------: | :--------------------------: | :---------------: |\n|  Boolean  |             true             |       false       |\n|  String   |        任何非空字符串        |   ''(空字符串)    |\n|  Number   | 任何非零数字值（包括无穷大） |     0 和 NaN      |\n| Undefined |        不适合这种规则        |     undefined     |\n\n### 1.4.5 Number 类型\n\nNumber 类型使用 IEEE754 格式来表示 整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。\n\n#### 1. 浮点数值\n\n所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字\n由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值 转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样 地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数，如下面的例子所示：\n\n```javascript\nvar floatNum1 = 1 // 小数点后面没有数字——解析为 1\nvar floatNum2 = 10.0 // 整数——解析为 10\n```\n浮点数值的高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。 例如:\n\n```javascript\nif (a + b == 0.3) {\nconsole.log('You got 0.3.')   // 不要做这样的测试！\n}\n```\n\n    在这个例子中，我们测试的是两个数的和是不是等于 0.3。如果这两个数\n    是 0.05和 0.25，或者是 0.15 和 0.15都不会有问题。而如前所述，如\n    果这两个数是 0.1和 0.2，那么测试将无法通过。因此，永远不 要测试某\n    个特定的浮点数值。\n\n#### 2. 数值范围\n\n由于内存的限制，ECMAScript 并不能保存世界上所有的数值。ECMAScript 能够表示的小数值保 存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的 结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具 体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转 换成 Infinity（正无穷）。\n\n    如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，\n    因为 Infinity 不是能够参与计算的数值\n\n#### 3. NaN\n\nNaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数 未返回数值的情况（这样就不会抛出错误了）\n",
    "clickCount": 99,
    "date": "2019-09-14T07:41:47.215Z"
  }
}